<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.data.avl - AVL trees 0.0.14 API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">data.avl API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">AVL trees</span> <span id="version">0.0.14</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="http://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#type-section">Types</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLMap" class="toc-entry-anchor">AVLMap</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLMapSeq" class="toc-entry-anchor">AVLMapSeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLNode" class="toc-entry-anchor">AVLNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLSet" class="toc-entry-anchor">AVLSet</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLTransientMap" class="toc-entry-anchor">AVLTransientMap</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLTransientSet" class="toc-entry-anchor">AVLTransientSet</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/merge" class="toc-entry-anchor">merge</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/merge-with" class="toc-entry-anchor">merge-with</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/nearest" class="toc-entry-anchor">nearest</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/rank-of" class="toc-entry-anchor">rank-of</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/sorted-map" class="toc-entry-anchor">sorted-map</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/sorted-map-by" class="toc-entry-anchor">sorted-map-by</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/sorted-set" class="toc-entry-anchor">sorted-set</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/sorted-set-by" class="toc-entry-anchor">sorted-set-by</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/split-at" class="toc-entry-anchor">split-at</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/split-key" class="toc-entry-anchor">split-key</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/subrange" class="toc-entry-anchor">subrange</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/union" class="toc-entry-anchor">union</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/unsafe-join" class="toc-entry-anchor">unsafe-join</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.data.avl">clojure.data.avl</span>
  - <span id="header-project">AVL trees</span> <span id="header-version">0.0.14</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>
<span id="author-line">by <span id="author-name">Micha≈Ç Marczyk</span><br /></span>
<br />Full namespace name: <span id="long-name">clojure.data.avl</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="http://github.com/clojure/data.avl/">http://github.com/clojure/data.avl/</a></div>
<pre id="namespace-docstr">An implementation of persistent sorted maps and sets based on AVL
trees which can be used as drop-in replacements for Clojure's
built-in sorted maps and sets based on red-black trees. Apart from
the standard sorted collection API, the provided map and set types
support the transients API and several additional logarithmic time
operations: rank queries via clojure.core/nth (select element by
rank) and clojure.data.avl/rank-of (discover rank of element),
"nearest key" lookups via clojure.data.avl/nearest, splits by key
and index via clojure.data.avl/split-key and
clojure.data.avl/split-at, respectively, and subsets/submaps using
clojure.data.avl/subrange.</pre>


<br />


<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLMap">AVLMap</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[comp tree cnt _meta _hash _hasheq]</span><br />
    Protocols: <span id="type-protocols">clojure.core.protocols/IKVReduce</span><br />
    Interfaces: <span id="type-interfaces">clojure.data.avl.IAVLTree, clojure.data.avl.INavigableTree, clojure.lang.Associative, clojure.lang.Counted, clojure.lang.IEditableCollection, clojure.lang.IFn, clojure.lang.IHashEq, clojure.lang.ILookup, clojure.lang.IMeta, clojure.lang.IObj, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.Indexed, clojure.lang.MapEquivalence, clojure.lang.Reversible, clojure.lang.Seqable, clojure.lang.Sorted, java.io.Serializable, java.lang.Iterable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLMapSeq">AVLMapSeq</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[_meta stack ascending? cnt _hash _hasheq]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Counted, clojure.lang.IHashEq, clojure.lang.IMeta, clojure.lang.IObj, clojure.lang.IPersistentCollection, clojure.lang.ISeq, clojure.lang.Seqable, clojure.lang.Sequential, java.io.Serializable, java.util.List</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLNode">AVLNode</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[edit key val left right height rank]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.data.avl.IAVLNode, clojure.lang.Associative, clojure.lang.Counted, clojure.lang.IEditableCollection, clojure.lang.IFn, clojure.lang.IHashEq, clojure.lang.ILookup, clojure.lang.IMapEntry, clojure.lang.IMeta, clojure.lang.IObj, clojure.lang.IPersistentCollection, clojure.lang.IPersistentStack, clojure.lang.IPersistentVector, clojure.lang.Indexed, clojure.lang.Reversible, clojure.lang.Seqable, clojure.lang.Sequential, java.io.Serializable, java.lang.Comparable, java.lang.Iterable, java.util.Collection, java.util.List, java.util.Map$Entry, java.util.RandomAccess</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLSet">AVLSet</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[_meta avl-map _hash _hasheq]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.data.avl.IAVLTree, clojure.data.avl.INavigableTree, clojure.lang.Counted, clojure.lang.IEditableCollection, clojure.lang.IFn, clojure.lang.IHashEq, clojure.lang.ILookup, clojure.lang.IMeta, clojure.lang.IObj, clojure.lang.IPersistentCollection, clojure.lang.IPersistentSet, clojure.lang.Indexed, clojure.lang.Reversible, clojure.lang.Seqable, clojure.lang.Sorted, java.io.Serializable, java.util.Set</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLTransientMap">AVLTransientMap</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[edit comp tree cnt]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Counted, clojure.lang.IFn, clojure.lang.ILookup, clojure.lang.ITransientAssociative, clojure.lang.ITransientCollection, clojure.lang.ITransientMap</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLTransientSet">AVLTransientSet</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[transient-avl-map]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Counted, clojure.lang.IFn, clojure.lang.ITransientCollection, clojure.lang.ITransientSet</span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/merge">merge</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (merge)
       (merge m)
       (merge m1 m2)
       (merge m1 m2 m3 &amp; more)
</pre>
    <pre id="var-docstr">(alpha)

Merges the given AVL maps which should all use the same comparator.
nil is accepted and converted into an empty AVL map. The value
returned is itself an AVL map, except in the nullary case in which
nil is returned.

In case of key collisions, mappings from maps further to the right
in the argument list take precedence.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L2119">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/merge-with">merge-with</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (merge-with f)
       (merge-with f m)
       (merge-with f m1 m2)
       (merge-with f m1 m2 m3 &amp; more)
</pre>
    <pre id="var-docstr">(alpha)

Merges the given AVL maps which should all use the same comparator.
nil is accepted and converted into an empty AVL map. The value
returned is itself an AVL map, except in the nullary case in which
nil is returned.

Use f to combine values in case of key collisions.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L2147">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/nearest">nearest</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (nearest coll test x)
</pre>
    <pre id="var-docstr">(alpha)

Equivalent to, but more efficient than, (first (subseq* coll test x)),
where subseq* is clojure.core/subseq for test in #{&gt;, &gt;=} and
clojure.core/rsubseq for test in #{&lt;, &lt;=}.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L1984">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/rank-of">rank-of</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (rank-of coll x)
</pre>
    <pre id="var-docstr">Returns the rank of x in coll or -1 if not present.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L1979">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/sorted-map">sorted-map</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sorted-map &amp; keyvals)
</pre>
    <pre id="var-docstr">keyval =&gt; key val
Returns a new AVL map with supplied mappings.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L1935">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/sorted-map-by">sorted-map-by</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sorted-map-by comparator &amp; keyvals)
</pre>
    <pre id="var-docstr">keyval =&gt; key val
Returns a new sorted map with supplied mappings, using the supplied
comparator.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L1949">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/sorted-set">sorted-set</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sorted-set &amp; keys)
</pre>
    <pre id="var-docstr">Returns a new sorted set with supplied keys.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L1966">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/sorted-set-by">sorted-set-by</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sorted-set-by comparator &amp; keys)
</pre>
    <pre id="var-docstr">Returns a new sorted set with supplied keys, using the supplied comparator.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L1971">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/split-at">split-at</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (split-at n coll)
</pre>
    <pre id="var-docstr">(alpha)

Equivalent to, but more efficient than,
[(into (empty coll) (take n coll))
 (into (empty coll) (drop n coll))].</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L2022">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/split-key">split-key</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (split-key k coll)
</pre>
    <pre id="var-docstr">(alpha)

Returns [left e? right], where left and right are collections of
the same type as coll and containing, respectively, the keys below
and above k in the ordering determined by coll's comparator, while
e? is the entry at key k for maps, the stored copy of the key k for
sets, nil if coll does not contain k.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L1993">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/subrange">subrange</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (subrange coll test limit)
       (subrange coll start-test start end-test end)
</pre>
    <pre id="var-docstr">(alpha)

Returns an AVL collection comprising the entries of coll between
start and end (in the sense determined by coll's comparator) in
logarithmic time. Whether the endpoints are themselves included in
the returned collection depends on the provided tests; start-test
must be either &gt; or &gt;=, end-test must be either &lt; or &lt;=.

When passed a single test and limit, subrange infers the other end
of the range from the test: &gt; / &gt;= mean to include items up to the
end of coll, &lt; / &lt;= mean to include items taken from the beginning
of coll.

(subrange &gt;= start &lt;= end) is equivalent to, but more efficient
than, (into (empty coll) (subseq coll &gt;= start &lt;= end).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L2036">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/union">union</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (union)
       (union s)
       (union s1 s2)
       (union s1 s2 s3 &amp; more)
</pre>
    <pre id="var-docstr">(alpha)

Computes the union of the given AVL sets which should all use the
same comparator. nil is accepted and converted into an empty AVL
set. The value returned is itself an AVL set, except in the nullary
case in which nil is returned.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L2175">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/unsafe-join">unsafe-join</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unsafe-join)
       (unsafe-join coll)
       (unsafe-join coll1 coll2)
       (unsafe-join coll1 coll2 coll3 &amp; more)
</pre>
    <pre id="var-docstr">(alpha)

ATTN: This function DOES NOT validate its inputs and WILL return
malformed results if the inputs do not satisfy the contract.

Merges or computes the union of colls. All colls must be AVL
collections of the same type using the same comparator. If collx
occurs earlier than colly among the arguments to unsafe-join,
collx's greatest element must be strictly smaller than the smallest
element of colly (in the sense determined by the comparator).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/7dc39e8b4e5ff331dc4624a8b21256c776f81385/src/main/clojure/clojure/data/avl.clj#L2091">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2015 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>