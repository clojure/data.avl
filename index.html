<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.data.avl - data.avl 0.2.0-SNAPSHOT API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">data.avl API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">data.avl</span> <span id="version">0.2.0-SNAPSHOT</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="https://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#type-section">Types</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLMap" class="toc-entry-anchor">AVLMap</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLMapSeq" class="toc-entry-anchor">AVLMapSeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLNode" class="toc-entry-anchor">AVLNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLSet" class="toc-entry-anchor">AVLSet</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLTransientMap" class="toc-entry-anchor">AVLTransientMap</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/AVLTransientSet" class="toc-entry-anchor">AVLTransientSet</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/nearest" class="toc-entry-anchor">nearest</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/rank-of" class="toc-entry-anchor">rank-of</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/sorted-map" class="toc-entry-anchor">sorted-map</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/sorted-map-by" class="toc-entry-anchor">sorted-map-by</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/sorted-set" class="toc-entry-anchor">sorted-set</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/sorted-set-by" class="toc-entry-anchor">sorted-set-by</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/split-at" class="toc-entry-anchor">split-at</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/split-key" class="toc-entry-anchor">split-key</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.data.avl/subrange" class="toc-entry-anchor">subrange</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.data.avl">clojure.data.avl</span>
  - <span id="header-project">data.avl</span> <span id="header-version">0.2.0-SNAPSHOT</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>
<span id="author-line">by <span id="author-name">Micha≈Ç Marczyk</span><br /></span>
<br />Full namespace name: <span id="long-name">clojure.data.avl</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="https://github.com/clojure/data.avl/">https://github.com/clojure/data.avl/</a></div>
<pre id="namespace-docstr">An implementation of persistent sorted maps and sets based on AVL
trees which can be used as drop-in replacements for Clojure's
built-in sorted maps and sets based on red-black trees. Apart from
the standard sorted collection API, the provided map and set types
support the transients API and several additional logarithmic time
operations: rank queries via clojure.core/nth (select element by
rank) and clojure.data.avl/rank-of (discover rank of element),
"nearest key" lookups via clojure.data.avl/nearest, splits by key
and index via clojure.data.avl/split-key and
clojure.data.avl/split-at, respectively, and subsets/submaps using
clojure.data.avl/subrange.</pre>


<br />


<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLMap">AVLMap</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[comp tree cnt _meta _hash _hasheq]</span><br />
    Protocols: <span id="type-protocols">clojure.core.protocols/IKVReduce</span><br />
    Interfaces: <span id="type-interfaces">clojure.data.avl.IAVLTree, clojure.data.avl.INavigableTree, clojure.lang.Associative, clojure.lang.Counted, clojure.lang.IEditableCollection, clojure.lang.IFn, clojure.lang.IHashEq, clojure.lang.ILookup, clojure.lang.IMeta, clojure.lang.IObj, clojure.lang.IPersistentCollection, clojure.lang.IPersistentMap, clojure.lang.IReduce, clojure.lang.Indexed, clojure.lang.MapEquivalence, clojure.lang.Reversible, clojure.lang.Seqable, clojure.lang.Sorted, java.io.Serializable, java.lang.Iterable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLMapSeq">AVLMapSeq</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[_meta stack ascending? cnt _hash _hasheq]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Counted, clojure.lang.IHashEq, clojure.lang.IMeta, clojure.lang.IObj, clojure.lang.IPersistentCollection, clojure.lang.ISeq, clojure.lang.Seqable, clojure.lang.Sequential, java.io.Serializable, java.util.List</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLNode">AVLNode</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[edit key val left right height rank]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.data.avl.IAVLNode, clojure.lang.Associative, clojure.lang.Counted, clojure.lang.IEditableCollection, clojure.lang.IFn, clojure.lang.IHashEq, clojure.lang.ILookup, clojure.lang.IMapEntry, clojure.lang.IMeta, clojure.lang.IObj, clojure.lang.IPersistentCollection, clojure.lang.IPersistentStack, clojure.lang.IPersistentVector, clojure.lang.Indexed, clojure.lang.Reversible, clojure.lang.Seqable, clojure.lang.Sequential, java.io.Serializable, java.lang.Comparable, java.lang.Iterable, java.util.Collection, java.util.List, java.util.Map$Entry, java.util.RandomAccess</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLSet">AVLSet</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[_meta avl-map _hash _hasheq]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.data.avl.IAVLTree, clojure.data.avl.INavigableTree, clojure.lang.Counted, clojure.lang.IEditableCollection, clojure.lang.IFn, clojure.lang.IHashEq, clojure.lang.ILookup, clojure.lang.IMeta, clojure.lang.IObj, clojure.lang.IPersistentCollection, clojure.lang.IPersistentSet, clojure.lang.IReduce, clojure.lang.Indexed, clojure.lang.Reversible, clojure.lang.Seqable, clojure.lang.Sorted, java.io.Serializable, java.util.Set</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLTransientMap">AVLTransientMap</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[edit comp tree cnt]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.data.avl.ITransientAssociative2Impl, clojure.lang.Counted, clojure.lang.IFn, clojure.lang.ILookup, clojure.lang.ITransientAssociative, clojure.lang.ITransientCollection, clojure.lang.ITransientMap</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/AVLTransientSet">AVLTransientSet</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[transient-avl-map]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Counted, clojure.lang.IFn, clojure.lang.ITransientCollection, clojure.lang.ITransientSet</span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/nearest">nearest</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (nearest coll test x)
</pre>
    <pre id="var-docstr">(alpha)

Equivalent to, but more efficient than, (first (subseq* coll test x)),
where subseq* is clojure.core/subseq for test in #{&gt;, &gt;=} and
clojure.core/rsubseq for test in #{&lt;, &lt;=}.</pre>
    <pre id="var-specs"></pre>
    <span class="var-added"><span id="content">Added in data.avl version 0.0.12</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/0ac87796e6639e2f1da0406095d59656462d3e93/src/main/clojure/clojure/data/avl.clj#L1951">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/rank-of">rank-of</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (rank-of coll x)
</pre>
    <pre id="var-docstr">Returns the rank of x in coll or -1 if not present.</pre>
    <pre id="var-specs"></pre>
    <span class="var-added"><span id="content">Added in data.avl version 0.0.6</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/0ac87796e6639e2f1da0406095d59656462d3e93/src/main/clojure/clojure/data/avl.clj#L1945">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/sorted-map">sorted-map</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sorted-map &amp; keyvals)
</pre>
    <pre id="var-docstr">keyval =&gt; key val
Returns a new AVL map with supplied mappings.</pre>
    <pre id="var-specs"></pre>
    <span class="var-added"><span id="content">Added in data.avl version 0.0.1</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/0ac87796e6639e2f1da0406095d59656462d3e93/src/main/clojure/clojure/data/avl.clj#L1897">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/sorted-map-by">sorted-map-by</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sorted-map-by comparator &amp; keyvals)
</pre>
    <pre id="var-docstr">keyval =&gt; key val
Returns a new sorted map with supplied mappings, using the supplied
comparator.</pre>
    <pre id="var-specs"></pre>
    <span class="var-added"><span id="content">Added in data.avl version 0.0.1</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/0ac87796e6639e2f1da0406095d59656462d3e93/src/main/clojure/clojure/data/avl.clj#L1912">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/sorted-set">sorted-set</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sorted-set &amp; keys)
</pre>
    <pre id="var-docstr">Returns a new sorted set with supplied keys.</pre>
    <pre id="var-specs"></pre>
    <span class="var-added"><span id="content">Added in data.avl version 0.0.1</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/0ac87796e6639e2f1da0406095d59656462d3e93/src/main/clojure/clojure/data/avl.clj#L1930">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/sorted-set-by">sorted-set-by</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sorted-set-by comparator &amp; keys)
</pre>
    <pre id="var-docstr">Returns a new sorted set with supplied keys, using the supplied comparator.</pre>
    <pre id="var-specs"></pre>
    <span class="var-added"><span id="content">Added in data.avl version 0.0.1</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/0ac87796e6639e2f1da0406095d59656462d3e93/src/main/clojure/clojure/data/avl.clj#L1936">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/split-at">split-at</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (split-at n coll)
</pre>
    <pre id="var-docstr">(alpha)

Equivalent to, but more efficient than,
[(into (empty coll) (take n coll))
 (into (empty coll) (drop n coll))].</pre>
    <pre id="var-specs"></pre>
    <span class="var-added"><span id="content">Added in data.avl version 0.0.12</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/0ac87796e6639e2f1da0406095d59656462d3e93/src/main/clojure/clojure/data/avl.clj#L1991">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/split-key">split-key</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (split-key k coll)
</pre>
    <pre id="var-docstr">(alpha)

Returns [left e? right], where left and right are collections of
the same type as coll and containing, respectively, the keys below
and above k in the ordering determined by coll's comparator, while
e? is the entry at key k for maps, the stored copy of the key k for
sets, nil if coll does not contain k.</pre>
    <pre id="var-specs"></pre>
    <span class="var-added"><span id="content">Added in data.avl version 0.0.12</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/0ac87796e6639e2f1da0406095d59656462d3e93/src/main/clojure/clojure/data/avl.clj#L1961">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.data.avl/subrange">subrange</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (subrange coll test limit)
       (subrange coll start-test start end-test end)
</pre>
    <pre id="var-docstr">(alpha)

Returns an AVL collection comprising the entries of coll between
start and end (in the sense determined by coll's comparator) in
logarithmic time. Whether the endpoints are themselves included in
the returned collection depends on the provided tests; start-test
must be either &gt; or &gt;=, end-test must be either &lt; or &lt;=.

When passed a single test and limit, subrange infers the other end
of the range from the test: &gt; / &gt;= mean to include items up to the
end of coll, &lt; / &lt;= mean to include items taken from the beginning
of coll.

(subrange coll &gt;= start &lt;= end) is equivalent to, but more efficient
than, (into (empty coll) (subseq coll &gt;= start &lt;= end)).</pre>
    <pre id="var-specs"></pre>
    <span class="var-added"><span id="content">Added in data.avl version 0.0.12</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/data.avl/blob/0ac87796e6639e2f1da0406095d59656462d3e93/src/main/clojure/clojure/data/avl.clj#L2006">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2023 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>